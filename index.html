<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Nova Connect 4</title>
	<style>
		body {
			font-family: sans-serif;
			text-align: center;
			margin-top: 30px;
		}
		table {
			margin: 0 auto;
			border-spacing: 5px;
		}
		td {
			width: 50px;
			height: 50px;
			background-color: #ddd;
			border-radius: 50%;
			cursor: pointer;
		}
		.player1 {
			background-color: red;
		}
		.player2 {
			background-color: yellow;
		}
	</style>
</head>
<body>
	<h1>Connect 4: You (Red) vs Nova (Yellow)</h1>
	<h2 id="status"></h2>
	<table id="board"></table>

	<script>
	// board dimensions
	const ROWS = 6;
	const COLS = 7;

	// scoring and search depth
	const SCORES = { 0: 0, 1: 1, 2: 10, 3: 100, 4: 10000 };
	const MAX_DEPTH = 6;

	const board = [];
	let gameOver = false;
	const status = document.getElementById('status');

	function createBoard() {
		const table = document.getElementById('board');
		table.innerHTML = '';
		for (let r = 0; r < ROWS; r++) {
			board[r] = [];
			const row = document.createElement('tr');
			for (let c = 0; c < COLS; c++) {
				board[r][c] = '';
				const cell = document.createElement('td');
				cell.dataset.row = r;
				cell.dataset.col = c;
				cell.onclick = () => handlePlayerMove(c);
				row.appendChild(cell);
			}
			table.appendChild(row);
		}
	}

	function handlePlayerMove(col) {
		if (gameOver) return;
		for (let r = ROWS - 1; r >= 0; r--) {
			if (board[r][col] === '') {
				board[r][col] = 'R';
				render();
				if (checkWin('R')) {
					status.textContent = 'You win!';
					gameOver = true;
					reportGameResult("Connect 4", "win");
					return;
				}
				if (isDraw()) {
					status.textContent = "It's a draw!";
					gameOver = true;
					reportGameResult("Connect 4", "draw");
					return;
				}
				setTimeout(novaMove, 300);
				return;
			}
		}
	}

	function novaMove() {
		const best = minimax(board, MAX_DEPTH, -Infinity, +Infinity, true);
		let col = best.move;
		// fallback if minimax didn't return a move
		if (typeof col === 'undefined') {
			for (let c = 0; c < COLS; c++) {
				if (getNextOpenRow(board, c) !== -1) {
					col = c;
					break;
				}
			}
		}
		for (let r = ROWS - 1; r >= 0; r--) {
			if (board[r][col] === '') {
				board[r][col] = 'Y';
				break;
			}
		}
		render();
		if (checkWin('Y')) {
			status.textContent = 'Nova wins!';
			gameOver = true;
			reportGameResult("Connect 4", "lose");
		} else if (isDraw()) {
			status.textContent = "It's a draw!";
			gameOver = true;
			reportGameResult("Connect 4", "draw");
		}
	}

	function minimax(position, depth, alpha, beta, maximizingPlayer) {
		if (checkWinBoard(position, 'Y')) return { score: +Infinity };
		if (checkWinBoard(position, 'R')) return { score: -Infinity };
		if (isBoardFull(position) || depth === 0) {
			return { score: evaluate(position) };
		}

		if (maximizingPlayer) {
			let maxEval = -Infinity, bestMove = 0;
			for (let c = 0; c < COLS; c++) {
				const r = getNextOpenRow(position, c);
				if (r === -1) continue;
				position[r][c] = 'Y';
				const eval = minimax(position, depth - 1, alpha, beta, false).score;
				position[r][c] = '';
				if (eval > maxEval) {
					maxEval = eval;
					bestMove = c;
				}
				alpha = Math.max(alpha, eval);
				if (beta <= alpha) break;
			}
			return { score: maxEval, move: bestMove };
		} else {
			let minEval = +Infinity, bestMove = 0;
			for (let c = 0; c < COLS; c++) {
				const r = getNextOpenRow(position, c);
				if (r === -1) continue;
				position[r][c] = 'R';
				const eval = minimax(position, depth - 1, alpha, beta, true).score;
				position[r][c] = '';
				if (eval < minEval) {
					minEval = eval;
					bestMove = c;
				}
				beta = Math.min(beta, eval);
				if (beta <= alpha) break;
			}
			return { score: minEval, move: bestMove };
		}
	}

	function getNextOpenRow(bd, col) {
		for (let r = ROWS - 1; r >= 0; r--) {
			if (bd[r][col] === '') return r;
		}
		return -1;
	}

	function isBoardFull(bd) {
		return bd[0].every(cell => cell !== '');
	}

	function checkWinBoard(bd, player) {
		for (let r = 0; r < ROWS; r++) {
			for (let c = 0; c < COLS; c++) {
				if (c + 3 < COLS &&
					bd[r][c] === player &&
					bd[r][c+1] === player &&
					bd[r][c+2] === player &&
					bd[r][c+3] === player) return true;
				if (r + 3 < ROWS &&
					bd[r][c] === player &&
					bd[r+1][c] === player &&
					bd[r+2][c] === player &&
					bd[r+3][c] === player) return true;
				if (r + 3 < ROWS && c + 3 < COLS &&
					bd[r][c] === player &&
					bd[r+1][c+1] === player &&
					bd[r+2][c+2] === player &&
					bd[r+3][c+3] === player) return true;
				if (r - 3 >= 0 && c + 3 < COLS &&
					bd[r][c] === player &&
					bd[r-1][c+1] === player &&
					bd[r-2][c+2] === player &&
					bd[r-3][c+3] === player) return true;
			}
		}
		return false;
	}

	function evaluate(bd) {
		let score = 0;
		for (let r = 0; r < ROWS; r++) {
			for (let c = 0; c < COLS; c++) {
				if (c + 3 < COLS) {
					const w = [bd[r][c], bd[r][c+1], bd[r][c+2], bd[r][c+3]];
					score += scoreWindow(w);
				}
				if (r + 3 < ROWS) {
					const w = [bd[r][c], bd[r+1][c], bd[r+2][c], bd[r+3][c]];
					score += scoreWindow(w);
				}
				if (r + 3 < ROWS && c + 3 < COLS) {
					const w = [bd[r][c], bd[r+1][c+1], bd[r+2][c+2], bd[r+3][c+3]];
					score += scoreWindow(w);
				}
				if (r - 3 >= 0 && c + 3 < COLS) {
					const w = [bd[r][c], bd[r-1][c+1], bd[r-2][c+2], bd[r-3][c+3]];
					score += scoreWindow(w);
				}
			}
		}
		return score;
	}

	function scoreWindow(win) {
		const y = win.filter(v => v === 'Y').length;
		const r = win.filter(v => v === 'R').length;
		if (y > 0 && r > 0) return 0;
		if (y > 0) return SCORES[y];
		if (r > 0) return -SCORES[r];
		return 0;
	}

	function isDraw() {
		return board[0].every(cell => cell !== '');
	}

	function render() {
		const table = document.getElementById('board');
		for (let r = 0; r < ROWS; r++) {
			for (let c = 0; c < COLS; c++) {
				const cell = table.rows[r].cells[c];
				cell.className = board[r][c] === 'R' ? 'player1' : board[r][c] === 'Y' ? 'player2' : '';
			}
		}
	}

	async function reportGameResult(gameName, outcome) {
		const params = new URLSearchParams(window.location.search);
		const userID = params.get("user");
		if (!userID) return;
		const content = `<@${userID}> finished ${gameName}: **${outcome.toUpperCase()}**`;
		await fetch("https://discord.com/api/webhooks/1370828516551295078/utPrT9ERPaCam4c_SCnTR3s7iEcyKpffUgW39Q7mdhhDFGbh7skS5kMiEnVSYtgZ1Jay", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({ content })
		});
	}

	createBoard();
	</script>
</body>
</html>
