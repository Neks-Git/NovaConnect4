<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Unbeatable Connect 4</title>
	<style>
		body {
			font-family: sans-serif;
			text-align: center;
			background: #f0f0f0;
		}
		#board {
			display: grid;
			grid-template-columns: repeat(7, 60px);
			grid-gap: 5px;
			justify-content: center;
			margin-top: 20px;
		}
		.cell {
			width: 60px;
			height: 60px;
			background-color: #3498db;
			border-radius: 50%;
			border: 2px solid #2980b9;
			box-sizing: border-box;
			cursor: pointer;
		}
		.cell.empty:hover {
			background-color: #85c1e9;
		}
		.red {
			background-color: red !important;
		}
		.yellow {
			background-color: yellow !important;
		}
		#winner {
			font-weight: bold;
			color: green;
		}
	</style>
</head>
<body>
	<h1>Connect 4 - UNBEATABLE AI</h1>
	<div id="board"></div>
	<div id="status">Your Turn: <span id="turn">Red</span></div>
	<button onclick="resetGame()">Restart</button>

	<script>
		const ROWS = 6;
		const COLS = 7;
		const DEPTH = 5;

		let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
		let currentPlayer = 'red';
		let gameOver = false;

		const boardDiv = document.getElementById('board');
		const turnSpan = document.getElementById('turn');
		const statusDiv = document.getElementById('status');

		function drawBoard() {
			boardDiv.innerHTML = '';
			for (let r = 0; r < ROWS; r++) {
				for (let c = 0; c < COLS; c++) {
					const cell = document.createElement('div');
					cell.className = 'cell';
					cell.dataset.row = r;
					cell.dataset.col = c;
					if (!board[r][c]) {
						cell.classList.add('empty');
						cell.onclick = handleClick;
					} else {
						cell.classList.add(board[r][c]);
					}
					boardDiv.appendChild(cell);
				}
			}
		}

		function handleClick(e) {
			if (gameOver || currentPlayer !== 'red') return;
			const col = parseInt(e.target.dataset.col);
			if (makeMove(col, 'red')) {
				if (checkWin('red')) return endGame('Red wins!');
				if (isDraw()) return endGame("It's a draw!");
				currentPlayer = 'yellow';
				turnSpan.textContent = 'Yellow (AI)';
				setTimeout(() => {
					let bestMove = getBestMove(board, DEPTH, -Infinity, Infinity, true).col;
					makeMove(bestMove, 'yellow');
					if (checkWin('yellow')) return endGame('Yellow (AI) wins!');
					if (isDraw()) return endGame("It's a draw!");
					currentPlayer = 'red';
					turnSpan.textContent = 'Red';
				}, 200);
			}
		}

		function makeMove(col, player) {
			for (let r = ROWS - 1; r >= 0; r--) {
				if (!board[r][col]) {
					board[r][col] = player;
					drawBoard();
					return true;
				}
			}
			return false;
		}

		function undoMove(col) {
			for (let r = 0; r < ROWS; r++) {
				if (board[r][col]) {
					board[r][col] = null;
					return;
				}
			}
		}

		function isDraw() {
			return board[0].every(cell => cell);
		}

		function endGame(msg) {
			gameOver = true;
			statusDiv.innerHTML = `<span id="winner">${msg}</span>`;
		}

		function checkWin(player) {
			for (let r = 0; r < ROWS; r++) {
				for (let c = 0; c < COLS; c++) {
					if (
						checkLine(r, c, 0, 1, player) ||
						checkLine(r, c, 1, 0, player) ||
						checkLine(r, c, 1, 1, player) ||
						checkLine(r, c, 1, -1, player)
					) {
						return true;
					}
				}
			}
			return false;
		}

		function checkLine(r, c, dr, dc, player) {
			for (let i = 0; i < 4; i++) {
				let rr = r + dr * i;
				let cc = c + dc * i;
				if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS || board[rr][cc] !== player) {
					return false;
				}
			}
			return true;
		}

		function getBestMove(boardState, depth, alpha, beta, maximizing) {
			if (checkWin('yellow')) return { score: 1000 - depth };
			if (checkWin('red')) return { score: -1000 + depth };
			if (isDraw() || depth === 0) return { score: evaluateBoard(boardState) };

			const validCols = [...Array(COLS).keys()].filter(c => !boardState[0][c]);
			if (maximizing) {
				let maxEval = -Infinity;
				let bestCol = validCols[0];
				for (const col of validCols) {
					if (!makeMove(col, 'yellow')) continue;
					let eval = getBestMove(boardState, depth - 1, alpha, beta, false).score;
					undoMove(col);
					if (eval > maxEval) {
						maxEval = eval;
						bestCol = col;
					}
					alpha = Math.max(alpha, eval);
					if (beta <= alpha) break;
				}
				return { score: maxEval, col: bestCol };
			} else {
				let minEval = Infinity;
				let bestCol = validCols[0];
				for (const col of validCols) {
					if (!makeMove(col, 'red')) continue;
					let eval = getBestMove(boardState, depth - 1, alpha, beta, true).score;
					undoMove(col);
					if (eval < minEval) {
						minEval = eval;
						bestCol = col;
					}
					beta = Math.min(beta, eval);
					if (beta <= alpha) break;
				}
				return { score: minEval, col: bestCol };
			}
		}

		function evaluateBoard(b) {
			let score = 0;
			const centerCol = COLS >> 1;
			for (let r = 0; r < ROWS; r++) {
				if (b[r][centerCol] === 'yellow') score += 3;
			}
			return score;
		}

		function resetGame() {
			board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
			currentPlayer = 'red';
			gameOver = false;
			turnSpan.textContent = 'Red';
			statusDiv.innerHTML = 'Your Turn: <span id="turn">Red</span>';
			drawBoard();
		}

		drawBoard();
	</script>
</body>
</html>
